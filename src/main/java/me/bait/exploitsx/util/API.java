package me.bait.exploitsx.util;

import me.bait.exploitsx.ExploitsX;
import me.bait.exploitsx.Messages;
import me.bait.exploitsx.chatco.AllChat;
import org.bukkit.*;
import org.bukkit.entity.Player;

import java.io.*;
import java.text.NumberFormat;
import java.util.Locale;

@SuppressWarnings({"unused"})
public class API {
    public static int timeSeconds = 0;
    public static long memUsed = 0;
    public static long memTotal = 0;
    public static long memFree = 0;

    static Locale locale = Locale.ENGLISH;
    static NumberFormat nf = NumberFormat.getNumberInstance(locale);
    static int version = Integer.parseInt(Bukkit.getServer().getBukkitVersion().split(Messages.getString("API.0"))[0]
            .replaceAll(Messages.getString("API.1"), Messages.getString("API.2")));

    public static void alertMessage(String message) {
        sendOpMessage(message);
        println(message);
    }

    public static void alertMessageChatCo(String message) {
        for (Player online : Bukkit.getOnlinePlayers()) {
            if (online.isOp()) {
                if (!AllChat.socialspy.containsKey(online)) return;
                if (AllChat.socialspy.get(online) == 1)
                    online.sendMessage(ChatColor.translateAlternateColorCodes('&', message));
            }
        }
        println(message);
    }

    public static void clearMemFiles(final String worldName) {
        final String nether = worldName.concat(Messages.getString("API.3"));
        final String end = worldName.concat(Messages.getString("API.4"));
        final File fortress = new File(nether + Messages.getString("API.5"));
        final File villagesNether = new File(nether + Messages.getString("API.6"));
        final File endCity = new File(end + Messages.getString("API.7"));
        final File villagesEnd = new File(end + Messages.getString("API.8"));
        final File village = new File(worldName + Messages.getString("API.9"));
        final File villages = new File(worldName + Messages.getString("API.10"));

        println(getPrefix() + Messages.getString("API.11"));

        try {
            fortress.delete();
            villagesNether.delete();
            endCity.delete();
            villagesEnd.delete();
            village.delete();
            villages.delete();
        } finally {
            println(getPrefix() + Messages.getString("API.12"));
        }
    }

    public static void crashPlayer(Player player) {
        for (int i = 0; i < 150; i++) {
            player.spawnParticle(Particle.EXPLOSION_HUGE, player.getLocation(), Integer.MAX_VALUE, 1, 1, 1);
        }
    }

    public static String format(double tps) {
        String val;

        if (tps > 18.0D) {
            val = Messages.getString("API.14");
        } else if (tps > 16.0D) {
            val = Messages.getString("API.15");
        } else if (tps > 14.0D) {
            val = Messages.getString("API.16");
        } else if (tps > 10.0D) {
            val = Messages.getString("API.17");
        } else if (tps > 6.0D) {
            val = Messages.getString("API.18");
        } else if (tps > 3.0D) {
            val = Messages.getString("API.19");
        } else {
            val = Messages.getString("API.20");
        }
        return (val + ((tps > 20.0D) ? Messages.getString("API.21") : Messages.getString("API.22"))
                + String.format(Messages.getString("API.23"),
                Math.min(Math.round(tps * 100.0D) / 100.0D, 20.0D)));
    }

    // this is from stackoverflow VVV do not go claiming you made it dumbass lmao
    public static String getFormattedInterval(long s) {
        long seconds = s % 60L;
        long minutes = s / 60L % 60L;
        long hours = s / 3600L % 24L;
        long days = s / 86400L;
        return String.format(Messages.getString("API.24"),
                days, hours, minutes, seconds);
    }

    public static long getMemFree() {
        return memFree;
    }

    public static long getMemTotal() {
        return memTotal;
    }

    public static long getMemUsed() {
        return memUsed;
    }

    public static void broadcast(String s) {
        for (Player p : Bukkit.getOnlinePlayers()) {
            p.sendMessage(ChatColor.translateAlternateColorCodes('&', s));
        }
    }

    public static Player getNearestPlayer(double i, Location loc) {
        Player rtn = null;
        for (Player nearby : loc.getNearbyPlayers(i)) {
            if (rtn == null) {
                rtn = nearby;
            } else {
                if (nearby.getLocation().distance(loc) < rtn.getLocation().distance(loc)) {
                    rtn = nearby;
                }
            }
        }
        return rtn;
    }

    public static String getPrefix() {
        String prefix = Messages.getString("API.52");
        if (ConfigHelper.getBoolean(Messages.getString("API.53"))) {
            prefix = ChatColor.LIGHT_PURPLE + Messages.getString("API.54") + ChatColor.GOLD
                    + Messages.getString("API.55") + ChatColor.BLUE
                    + ExploitsX.getPlugin().getDescription().getVersion() + ChatColor.LIGHT_PURPLE
                    + Messages.getString("API.56")
                    + ChatColor.RESET;
        }
        return prefix;
    }

    public static int getRandom(int max) {
        return (int) (Math.random() * max);
    }

    public static double getTps() {
        double val = (TPS.getTPS() + ExploitsX.getPlugin().getConfig().getInt(Messages.getString("API.57")));
        return Double.parseDouble(nf.format(val));
    }

    public static int getVersionInt() {
        return version;
    }

    public static boolean isShulkerBox(String s) {
        switch (s) {
            case "BLACK_SHULKER_BOX":
            case "BLUE_SHULKER_BOX":
            case "BROWN_SHULKER_BOX":
            case "CYAN_SHULKER_BOX":
            case "GRAY_SHULKER_BOX":
            case "GREEN_SHULKER_BOX":
            case "LIGHT_BLUE_SHULKER_BOX":
            case "LIME_SHULKER_BOX":
            case "MAGENTA_SHULKER_BOX":
            case "ORANGE_SHULKER_BOX":
            case "PINK_SHULKER_BOX":
            case "PURPLE_SHULKER_BOX":
            case "RED_SHULKER_BOX":
            case "WHITE_SHULKER_BOX":
            case "YELLOW_SHULKER_BOX":
            case "LIGHT_GRAY_SHULKER_BOX":
            case "SILVER_SHULKER_BOX":
                return true;
            default:
                return false;
        }
    }

    public static boolean isTile(String s) {
        switch (s) {
            case "REDSTONE_COMPARATOR":
            case "BEE_HIVE":
            case "ENDER_CHEST":
            case "LIGHT_GRAY_SHULKER_BOX":
            case "SMOKER":
            case "DROPPER":
            case "END_GATEWAY":
            case "DAYLIGHT_DETECTOR":
            case "REPEATING_COMMAND_BLOCK":
            case "MOB_SPAWNER":
            case "PINK_SHULKER_BOX":
            case "LIME_SHULKER_BOX":
            case "SPAWNER":
            case "DISPENSER":
            case "WHITE_SHULKER_BOX":
            case "PURPLE_SHULKER_BOX":
            case "MAGENTA_SHULKER_BOX":
            case "JUKEBOX":
            case "RED_SHULKER_BOX":
            case "TRAPPED_CHEST":
            case "SIGN_POST":
            case "ORANGE_SHULKER_BOX":
            case "BLUE_SHULKER_BOX":
            case "WALL_SIGN":
            case "BELL":
            case "CHEST":
            case "DIODE":
            case "BLAST_FURNACE":
            case "LIGHT_BLUE_SHULKER_BOX":
            case "SILVER_SHULKER_BOX":
            case "FURNACE":
            case "COMMAND_BLOCK":
            case "BROWN_SHULKER_BOX":
            case "BEENEST":
            case "CAMPFIRE":
            case "CHAIN_COMMAND_BLOCK":
            case "CYAN_SHULKER_BOX":
            case "NOTE_BLOCK":
            case "GREEN_SHULKER_BOX":
            case "BREWING_STAND":
            case "YELLOW_SHULKER_BOX":
            case "ENCHANTMENT_TABLE":
            case "BLACK_SHULKER_BOX":
            case "BARREL":
            case "BEACON":
            case "GRAY_SHULKER_BOX":
            case "HOPPER":
                return true;
            default:
                return false;
        }
    }

    public static void kickPlayer(Player player, String string) {
        Bukkit.getScheduler().runTask(ExploitsX.getPlugin(), () -> player.kickPlayer(ChatColor.translateAlternateColorCodes('&', string)));
    }

    public static void println(String string) {
        Bukkit.getLogger().info(ChatColor.translateAlternateColorCodes('&', string));
    }

    public static void runMcCommand(String string) {
        Bukkit.getServer().dispatchCommand(Bukkit.getConsoleSender(), string);
    }

    public static void runSysCommand(String string) {
        try {
            Process process = Runtime.getRuntime().exec(string);
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;

            while ((line = reader.readLine()) != null) {
                API.println(line);
            }

            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void sendMessage(Player player, String string) {
        player.sendMessage(ChatColor.translateAlternateColorCodes('&', string));
    }

    public static void sendOpMessage(String message) {
        for (Player online : Bukkit.getOnlinePlayers()) {
            if (online.isOp()) {
                online.sendMessage(ChatColor.translateAlternateColorCodes('&', message));
            }
        }
    }

    public static void sendPlayerToServer(Player player, String server) {
        try {
            ByteArrayOutputStream b = new ByteArrayOutputStream();
            DataOutputStream out = new DataOutputStream(b);

            out.writeUTF(Messages.getString("API.122"));
            out.writeUTF(server);

            player.sendPluginMessage(ExploitsX.getPlugin(), Messages.getString("API.123"), b.toByteArray());

            b.close();
            out.close();
        } catch (Exception e) {
            e.printStackTrace();
            player.kickPlayer(getPrefix() + Messages.getString("API.124"));
        }
    }

    public static void teleportPlayer(Player player, int x, int y, int z, World g) {
        player.teleport(new Location(g, x, y, z));
    }

    public static void uptime() {
        nf.setMinimumFractionDigits(2);
        nf.setMaximumFractionDigits(2);

        Runtime r = Runtime.getRuntime();

        Bukkit.getScheduler().runTaskTimer(ExploitsX.getPlugin(), () -> {
            memUsed = ((r.totalMemory() - r.freeMemory()) / 1048576);
            memTotal = r.totalMemory() / 1048576;
            memFree = r.freeMemory() / 1048576;
            timeSeconds++;
        }, 20, 20);
    }
}