package me.bait.exploitsx.exploits;

import me.bait.exploitsx.util.API;
import me.bait.exploitsx.util.ConfigHelper;
import me.bait.exploitsx.util.ViolationUtils;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerQuitEvent;

public class MapFill implements Listener {

    static boolean enable = ConfigHelper.getBoolean("mapspampatch");

    static boolean clearleave = ConfigHelper.getBoolean("mapclearleave");

    static int increment = ConfigHelper.getInt("mapspamincrement");
    ViolationUtils mapViolations = new ViolationUtils();

    public static void reload() {
        enable = ConfigHelper.getBoolean("mapspampatch");
        clearleave = ConfigHelper.getBoolean("mapclearleave");
        increment = ConfigHelper.getInt("mapspamincrement");
    }

    @EventHandler(priority = EventPriority.HIGH)
    public void onPlayerInteractEvent(PlayerInteractEvent event) {
        if (event.getItem() != null) {
            Action a = event.getAction();
            if (((a == Action.RIGHT_CLICK_AIR || a == Action.RIGHT_CLICK_BLOCK) && (event.getItem() != null)
                    && (event.getItem().getType().toString().toLowerCase().contains("map"))) && enable) {
                Player p = event.getPlayer();
                mapViolations.addVls(p, 1);
                if (mapViolations.getVls(p) >= increment) {
                    event.setCancelled(true);
                    API.sendMessage(p, API.getPrefix() + "> &6Please relog to fill maps.");
                }
            }
        }
    }

    @EventHandler
    public void onPlayerLeave(PlayerQuitEvent event) {
        if (enable && clearleave) {
            mapViolations.resetVls(event.getPlayer());
        }
    }
}
