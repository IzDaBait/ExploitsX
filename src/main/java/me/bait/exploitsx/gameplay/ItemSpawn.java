package me.bait.exploitsx.gameplay;

import me.bait.exploitsx.util.API;
import net.minecraft.server.v1_12_R1.Item;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.block.ShulkerBox;
import org.bukkit.craftbukkit.v1_12_R1.inventory.CraftItemStack;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.player.PlayerAttemptPickupItemEvent;
import org.bukkit.event.player.PlayerDropItemEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BlockStateMeta;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

//-- // WARNING \\ --
// Licence publique Creative Commons Attribution - Utilisation non commerciale - Pas d’Œuvre dérivée 4.0 International
//        Lorsque Vous exercez les Droits accordés par la licence (définis ci-dessous), Vous acceptez d'être lié par les termes et conditions de la présente Licence publique Creative Commons Attribution - Utilisation non commerciale - Pas d’Œuvre dérivée 4.0 International (la « Licence publique »). Dans la mesure où la présente Licence publique peut être interprétée comme un contrat, Vous bénéficiez des Droits accordés par la licence en contrepartie de Votre acceptation des présents termes et conditions, et le Donneur de licence Vous accorde ces droits en contrepartie des avantages que lui procure le fait de mettre à disposition l’Œuvre sous licence en vertu des présents termes et conditions.
//-- https://creativecommons.org/licenses/by-nc-nd/4.0/deed.fr
//-- ExploitsX Sebastian Giheta 2019-2020
//-- //         \\ --

public class ItemSpawn implements Listener {

	public static void infItem(Player p, String[] a) {
		if (a.length < 1)
			return;
		ItemStack itemStack = new ItemStack(Material.matchMaterial(a[0]));
		String rel = "0";
		if (a.length >= 2)
			rel = a[1];
		ArrayList<String> lore = new ArrayList<>();
		lore.add("x[Inf]");
		itemStack.setLore(lore);
		itemStack.setDurability(Short.parseShort(rel));
		p.getInventory().addItem(itemStack);
		for (ItemStack i : p.getInventory().getContents()) {
			if (i != null && i.hasItemMeta() && i.getLore() != null && i.getLore().equals(lore)) {
				i.setAmount(117);
			}
		}
	}

	@SuppressWarnings("rawtypes")
	public static void summon(Player p, String[] a) {
		if (a.length < 2)
			return;
		if (API.getVersionInt() != 1122) {
			p.sendMessage(ChatColor.DARK_RED
					+ "This command only supports server versions of 1.12.2. We'll attempt to run it, but you will probably get an error.");
		}
		List shulkerList = Arrays.asList(Item.getById(219), Item.getById(220), Item.getById(221),
				Item.getById(222), Item.getById(223), Item.getById(224), Item.getById(225), Item.getById(226),
				Item.getById(227), Item.getById(228), Item.getById(229), Item.getById(230), Item.getById(231),
				Item.getById(232), Item.getById(233), Item.getById(234));
		if (Material.matchMaterial(a[1]) != null && Material.matchMaterial(a[0]) != null) {
			String rel = "0";
			if (a.length >= 3)
				rel = "0";
			ItemStack itemStack = new ItemStack(Material.matchMaterial(a[0]));
			BlockStateMeta bsm = (BlockStateMeta) itemStack.getItemMeta();
			ShulkerBox box = (ShulkerBox) bsm.getBlockState();
			Inventory inventory = box.getInventory();
			if (shulkerList.contains(CraftItemStack.asNMSCopy(itemStack).getItem())) {
				ItemStack i = new ItemStack(Material.matchMaterial(a[1]), 64);
				if (a[2] != null) {
					i.setDurability(Short.parseShort(rel));
				}
				for (int i1 = 0; i1 < inventory.getSize(); i1++) {
					box.getInventory().setItem(i1, i);
				}
				bsm.setBlockState(box);
				itemStack.setItemMeta(bsm);
				p.getInventory().addItem(itemStack);
			} else {
				p.sendMessage(ChatColor.DARK_RED + "You must input a shulker box type as a first variable.");
			}
		} else {
			p.sendMessage(ChatColor.DARK_RED
					+ "Usage: /xitem (shulker box type) (item type) (item durability), Example: /xitem RED_SHULKER_BOX WOOL (0-15)");
		}
	}

	@EventHandler
	public void drop(PlayerDropItemEvent e) {
		if (e.getItemDrop() == null)
			return;
		if (e.getItemDrop().getItemStack().getLore() == null)
			return;
		ArrayList<String> lore = new ArrayList<>();
		lore.add("x[Inf]");
		if (e.getItemDrop().getItemStack().getLore().equals(lore)) {
			e.getItemDrop().getItemStack().setAmount(0);
			e.setCancelled(true);
			for (ItemStack i : e.getPlayer().getInventory().getContents()) {
				if (i != null && Objects.equals(i.getLore(), lore) && i.getType() == e.getItemDrop().getItemStack().getType()) {
					i.setAmount(0);
					e.getPlayer().sendMessage(ChatColor.translateAlternateColorCodes('&',
							"&4Removed infinite item with a type of " + i.getType()));
				}
			}
		}
	}

	@EventHandler
	public void onplace(BlockPlaceEvent event) {
		ArrayList<String> lore = new ArrayList<>();
		lore.add("x[Inf]");
		if (event.getItemInHand() != null && event.getItemInHand().getLore() != null) {
			if (event.getItemInHand().getLore().equals(lore)) {
				event.getItemInHand().setAmount(117);
			}
		}
	}

	@EventHandler
	public void pickup(PlayerAttemptPickupItemEvent e) {
		if (e.getItem() == null)
			return;
		if (e.getItem().getItemStack().getLore() == null)
			return;
		ArrayList<String> lore = new ArrayList<>();
		lore.add("x[Inf]");
		if (e.getItem().getItemStack().getLore().equals(lore)) {
			e.getItem().getItemStack().setAmount(0);
		}
	}
}
