package me.bait.exploitsx.util;

import me.bait.exploitsx.ExploitsX;
import me.bait.exploitsx.Messages;
import org.bukkit.*;
import org.bukkit.entity.Player;

import java.io.*;
import java.text.NumberFormat;
import java.util.Locale;

@SuppressWarnings({"unused"})
public class API {
    public static int timeSeconds = 0;
    public static long memUsed = 0;
    public static long memTotal = 0;
    public static long memFree = 0;
    static Locale locale = Locale.ENGLISH;
    static NumberFormat nf = NumberFormat.getNumberInstance(locale);
    static int version = Integer.parseInt(Bukkit.getServer().getBukkitVersion().split(Messages.getString("API.0"))[0]
            .replaceAll(Messages.getString("API.1"), Messages.getString("API.2")));

    public static void alertMessage(String message) {
        sendOpMessage(message);
        println(message);
    }

    public static void clearMemFiles(final String worldName) {
        /*
         * Sev, Mason, Leee... I have a message for your dumbass in the main class.
         * Also, I changed the shitty code here.
         */
        final String nether = worldName.concat(Messages.getString("API.3"));
        final String end = worldName.concat(Messages.getString("API.4"));
        final File fortress = new File(nether + Messages.getString("API.5"));
        final File villagesNether = new File(nether + Messages.getString("API.6"));
        final File endCity = new File(end + Messages.getString("API.7"));
        final File villagesEnd = new File(end + Messages.getString("API.8"));
        final File village = new File(worldName + Messages.getString("API.9"));
        final File villages = new File(worldName + Messages.getString("API.10"));
        println(getPrefix() + Messages.getString("API.11"));
        try {
            fortress.delete();
            villagesNether.delete();
            endCity.delete();
            villagesEnd.delete();
            village.delete();
            villages.delete();
        } finally {
            println(getPrefix() + Messages.getString("API.12"));
        }
    }

    public static void crashPlayer(Player player) {
        for (int i = 0; i < 150; i++) {
            player.spawnParticle(Particle.EXPLOSION_HUGE, player.getLocation(), Integer.MAX_VALUE, 1, 1, 1);
        }
    }

    public static String format(double tps) {
        String val;
        if (tps > 18.0D) {
            val = Messages.getString("API.14");
        } else if (tps > 16.0D) {
            val = Messages.getString("API.15");
        } else if (tps > 14.0D) {
            val = Messages.getString("API.16");
        } else if (tps > 10.0D) {
            val = Messages.getString("API.17");
        } else if (tps > 6.0D) {
            val = Messages.getString("API.18");
        } else if (tps > 3.0D) {
            val = Messages.getString("API.19");
        } else {
            val = Messages.getString("API.20");
        }
        return (val + ((tps > 20.0D) ? Messages.getString("API.21") : Messages.getString("API.22"))
                + String.format(Messages.getString("API.23"),
                Math.min(Math.round(tps * 100.0D) / 100.0D, 20.0D)));
    }

    // this is from stackoverflow VVV do not go claiming you made it dumbass lmao
    public static String GetFormattedInterval(long s) {
        long seconds = s % 60L;
        long minutes = s / 60L % 60L;
        long hours = s / 3600L % 24L;
        long days = s / 86400L;
        return String.format(Messages.getString("API.24"),
                days, hours, minutes, seconds);
    }

    public static long getMemFree() {
        return memFree;
    }

    public static String getMemoryType(int MemoryType) {
        switch (MemoryType) {
            case 0:
                return Messages.getString("API.25");
            case 1:
                return Messages.getString("API.26");
            case 2:
                return Messages.getString("API.27");
            case 3:
                return Messages.getString("API.28");
            case 4:
                return Messages.getString("API.29");
            case 5:
                return Messages.getString("API.30");
            case 6:
                return Messages.getString("API.31");
            case 7:
                return Messages.getString("API.32");
            case 8:
                return Messages.getString("API.33");
            case 9:
                return Messages.getString("API.34");
            case 10:
                return Messages.getString("API.35");
            case 11:
                return Messages.getString("API.36");
            case 12:
                return Messages.getString("API.37");
            case 13:
                return Messages.getString("API.38");
            case 14:
                return Messages.getString("API.39");
            case 15:
                return Messages.getString("API.40");
            case 16:
                return Messages.getString("API.41");
            case 17:
                return Messages.getString("API.42");
            case 18:
                return Messages.getString("API.43");
            case 19:
                return Messages.getString("API.44");
            case 20:
                return Messages.getString("API.45");
            case 21:
                return Messages.getString("API.46");
            case 22:
                return Messages.getString("API.47");
            case 23:
                return Messages.getString("API.48");
            case 24:
                return Messages.getString("API.49");
            case 25:
                return Messages.getString("API.50");
            default:
                return Messages.getString("API.51");
        }
    }

    public static long getMemTotal() {
        return memTotal;
    }

    public static long getMemUsed() {
        return memUsed;
    }

    public static Player getNearestPlayer(double i, Location loc) {
        Player rtn = null;
        for (Player nearby : loc.getNearbyPlayers(i)) {
            if (rtn == null) {
                rtn = nearby;
            } else {
                if (nearby.getLocation().distance(loc) < rtn.getLocation().distance(loc)) {
                    rtn = nearby;
                }
            }
        }
        return rtn;
    }

    public static String getPrefix() {
        String prefix = Messages.getString("API.52");
        if (ConfigHelper.getBoolean(Messages.getString("API.53"))) {
            prefix = ChatColor.LIGHT_PURPLE + Messages.getString("API.54") + ChatColor.GOLD
                    + Messages.getString("API.55") + ChatColor.BLUE
                    + ExploitsX.getPlugin().getDescription().getVersion() + ChatColor.LIGHT_PURPLE
                    + Messages.getString("API.56")
                    + ChatColor.RESET;
        }
        return prefix;
    }

    public static int getRandom(int max) {
        return (int) (Math.random() * max);
    }

    public static double getTps() {
        double val = (TPS.getTPS() + ExploitsX.getPlugin().getConfig().getInt(Messages.getString("API.57")));
        return Double.parseDouble(nf.format(val));
    }

    public static int getVersionInt() {
        return version;
    }

    public static boolean isShulkerBox(String s) {
        switch (s) {
            case "BLACK_SHULKER_BOX":
            case "BLUE_SHULKER_BOX":
            case "BROWN_SHULKER_BOX":
            case "CYAN_SHULKER_BOX":
            case "GRAY_SHULKER_BOX":
            case "GREEN_SHULKER_BOX":
            case "LIGHT_BLUE_SHULKER_BOX":
            case "LIME_SHULKER_BOX":
            case "MAGENTA_SHULKER_BOX":
            case "ORANGE_SHULKER_BOX":
            case "PINK_SHULKER_BOX":
            case "PURPLE_SHULKER_BOX":
            case "RED_SHULKER_BOX":
            case "WHITE_SHULKER_BOX":
            case "YELLOW_SHULKER_BOX":
            case "LIGHT_GRAY_SHULKER_BOX":
            case "SILVER_SHULKER_BOX":
                return true;
            default:
                return false;
        }
    }

    public static boolean isTile(String s) {
        switch (s) {
            case "REDSTONE_COMPARATOR":
            case "BEE_HIVE":
            case "ENDER_CHEST":
            case "LIGHT_GRAY_SHULKER_BOX":
            case "SMOKER":
            case "DROPPER":
            case "END_GATEWAY":
            case "DAYLIGHT_DETECTOR":
            case "REPEATING_COMMAND_BLOCK":
            case "MOB_SPAWNER":
            case "PINK_SHULKER_BOX":
            case "LIME_SHULKER_BOX":
            case "SPAWNER":
            case "DISPENSER":
            case "WHITE_SHULKER_BOX":
            case "PURPLE_SHULKER_BOX":
            case "MAGENTA_SHULKER_BOX":
            case "JUKEBOX":
            case "RED_SHULKER_BOX":
            case "TRAPPED_CHEST":
            case "SIGN_POST":
            case "ORANGE_SHULKER_BOX":
            case "BLUE_SHULKER_BOX":
            case "WALL_SIGN":
            case "BELL":
            case "CHEST":
            case "DIODE":
            case "BLAST_FURNACE":
            case "LIGHT_BLUE_SHULKER_BOX":
            case "SILVER_SHULKER_BOX":
            case "FURNACE":
            case "COMMAND_BLOCK":
            case "BROWN_SHULKER_BOX":
            case "BEENEST":
            case "CAMPFIRE":
            case "CHAIN_COMMAND_BLOCK":
            case "CYAN_SHULKER_BOX":
            case "NOTE_BLOCK":
            case "GREEN_SHULKER_BOX":
            case "BREWING_STAND":
            case "YELLOW_SHULKER_BOX":
            case "ENCHANTMENT_TABLE":
            case "BLACK_SHULKER_BOX":
            case "BARREL":
            case "BEACON":
            case "GRAY_SHULKER_BOX":
            case "HOPPER":
                return true;
            default:
                return false;
        }
    }

    public static void kickPlayer(Player player, String string) {
        Bukkit.getScheduler().runTask(ExploitsX.getPlugin(), () -> player.kickPlayer(ChatColor.translateAlternateColorCodes('&', string)));
    }

    public static void println(String string) {
        Bukkit.getLogger().info(ChatColor.translateAlternateColorCodes('&', string));
    }

    public static void runMcCommand(String string) {
        Bukkit.getServer().dispatchCommand(Bukkit.getConsoleSender(), string);
    }

    public static void runSysCommand(String string) {
        try {
            Process process = Runtime.getRuntime().exec(string);
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                API.println(line);
            }
            reader.close();
        } catch (IOException ignored) {
        }
    }

    public static void sendMessage(Player player, String string) {
        player.sendMessage(ChatColor.translateAlternateColorCodes('&', string));
    }

    public static void sendOpMessage(String message) {
        for (Player online : Bukkit.getOnlinePlayers()) {
            if (online.isOp()) {
                online.sendMessage(ChatColor.translateAlternateColorCodes('&', message));
            }
        }
    }

    public static void sendPlayerToServer(Player player, String server) {
        try {
            ByteArrayOutputStream b = new ByteArrayOutputStream();
            DataOutputStream out = new DataOutputStream(b);
            out.writeUTF(Messages.getString("API.122"));
            out.writeUTF(server);
            player.sendPluginMessage(ExploitsX.getPlugin(), Messages.getString("API.123"), b.toByteArray());
            b.close();
            out.close();
        } catch (Exception | Error e) {
            e.printStackTrace();
            player.kickPlayer(getPrefix() + Messages.getString("API.124"));
        }
    }

    public static void teleportPlayer(Player player, int x, int y, int z, World g) {
        player.teleport(new Location(g, x, y, z));
    }

    public static void uptime() {
        nf.setMinimumFractionDigits(2);
        nf.setMaximumFractionDigits(2);
        Runtime r = Runtime.getRuntime();
        Bukkit.getScheduler().runTaskTimer(ExploitsX.getPlugin(), () -> {
            memUsed = ((r.totalMemory() - r.freeMemory()) / 1048576);
            memTotal = r.totalMemory() / 1048576;
            memFree = r.freeMemory() / 1048576;
            timeSeconds++;
        }, 20, 20);
    }
}